function changes = full_gradient(Sigma, Sigma_inv, mdp_model,...
  mdp_data, example_samples, counts, mu, Kru, Kuu, Kuu_inv, KruKuu, Krr,...
  Kuu_grad, Kru_grad, Krr_grad, z, T, B) % TODO: KruKuu is not needed

  r_covariance_matrix = Krr - KruKuu * Kru;
  disp(r_covariance_matrix);
  grad_prediction_for_each_u = arrayfun(@(i) estimate_derivative(z(i, :),...
    Krr, Kru, Kuu, Kuu_inv, r_covariance_matrix, Kuu_grad, Kru_grad, Krr_grad, mdp_data, Sigma, Sigma_inv,...
    mu, mdp_model, example_samples, counts, T, B), 1:size(z, 1), 'Uniform', 0);
  estimated_grad = mean(cat(3, grad_prediction_for_each_u{:}), 3);

  not_estimated_lambda = arrayfun(@(i) counts' * (Kru_grad(:, :, i)' -...
    Kru' * Kuu_inv * Kuu_grad(:, :, i)) * Kuu_inv * mu +...
    0.5 * (trace(Kuu_inv * Kuu_grad(:, :, i) * Kuu_inv * Sigma) +...
    mu' * Kuu_inv * Kuu_grad(:, :, i) * Kuu_inv * mu -...
    trace(Kuu_inv * Kuu_grad(:, :, i))), 1:size(Kuu_grad, 3));
  not_estimated_mu = (counts' * Kru' * Kuu_inv)' - 0.5 * (Kuu_inv + Kuu_inv') * mu;
  not_estimated_elbo = 0.5 * log(det(Sigma)) - 0.5 * log(det(Kuu)) +...
    counts' * KruKuu * mu;
  not_estimated_B = 0.5 * (T + Sigma_inv) * B;

  not_estimated = vertcat(not_estimated_elbo, not_estimated_lambda',...
    diag(not_estimated_B), not_estimated_mu, get_lower_triangle(not_estimated_B));
  changes = not_estimated - 0.5 * estimated_grad;
end
